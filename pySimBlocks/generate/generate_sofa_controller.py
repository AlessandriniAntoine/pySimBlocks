import re
from pathlib import Path
from pySimBlocks.generate.generate_parameters import generate_parameters
from pySimBlocks.generate.generate_model import resolve_block_import


# ============================================================================
# 1. Transform SofaPlant → SofaExchangeIO for SOFA-side controller
# ============================================================================

def transform_block_for_sofa(block):
    """Convert SofaPlant block into SofaExchangeIO for controller generation."""
    if block["type"].lower() == "sofa_plant":
        return {
            "name": block["name"],
            "type": "sofa_exchange_i_o",
            "from": "systems",
            "input_keys": block["input_keys"],
            "output_keys": block["output_keys"],
        }
    return block


# ============================================================================
# 2. Pattern to remove ANY existing build_model() implementation
# ============================================================================

def remove_old_build_model(text):
    lines = text.split("\n")

    start = None
    indent = None

    # 1) trouver la ligne def build_model
    for i, line in enumerate(lines):
        stripped = line.lstrip()
        if stripped.startswith("def build_model"):
            start = i
            indent = len(line) - len(stripped)
            break

    if start is None:
        # no function found
        return text

    # 2) trouver la fin du bloc en utilisant l’indentation
    end = start + 1
    for j in range(start + 1, len(lines)):
        line = lines[j]
        # ligne vide → fait partie du bloc
        if not line.strip():
            continue
        current_indent = len(line) - len(line.lstrip())

        # fin du bloc lorsque l’indentation revient au même niveau ou moins
        if current_indent <= indent:
            end = j
            break
    else:
        # si on n'a jamais trouvé de fin, alors fin du fichier
        end = len(lines)

    # 3) supprimer toutes les lignes de start à end
    new_lines = lines[:start] + lines[end:]

    return "\n".join(new_lines)



# ============================================================================
# 3. Build code for block instantiation (CamelCase class name included)
# ============================================================================

def build_instantiation_line(block):
    """
    Produce: self.pid = Pid("pid", Kp=pid_Kp, Ki=pid_Ki)
    """
    name = block["name"]
    module, class_name = resolve_block_import(block["from"], block["type"])

    params = {
        k: f"{name}_{k}"
        for k in block.keys()
        if k not in ("name", "type", "from")
    }

    if params:
        pstr = ", ".join(f"{k}={v}" for k, v in params.items())
        return f'self.{name} = {class_name}("{name}", {pstr})'
    else:
        return f'self.{name} = {class_name}("{name}")'


# ============================================================================
# 4. Build final build_model() method code
# ============================================================================

def generate_build_model_code(blocks, connections, logs):
    lines = []
    indent = " " * 4

    lines.append(f"{indent}def build_model(self):")
    lines.append("")

    # Instantiation
    for blk in blocks:
        lines.append(f"{indent*2}{build_instantiation_line(blk)}")

    # Create model
    lines.append("")
    lines.append(f'{indent*2}self.model = Model("sofa_autogenerated_controller")')
    lines.append(f"{indent*2}for blk in [")

    for blk in blocks:
        lines.append(f"{indent*3}self.{blk['name']},")

    lines.append(f"{indent*2}]:")
    lines.append(f"{indent*3}self.model.add_block(blk)")
    lines.append("")

    # Connections
    lines.append(f"{indent*2}# Connections")
    for src_full, dst_full in connections:
        src, outp = src_full.split(".")
        dst, inp = dst_full.split(".")
        lines.append(f'{indent*2}self.model.connect("{src}", "{outp}", "{dst}", "{inp}")')

    # Logs
    logs_str = ", ".join(f'"{l}"' for l in logs)
    lines.append("")
    lines.append(f"{indent*2}self.variables_to_log = [{logs_str}]")
    lines.append("")

    return "\n".join(lines)


# ============================================================================
# 5. INJECTION of build_model() into user controller
# ============================================================================

def inject_build_model(controller_path, build_model_code, required_imports):
    path = Path(controller_path)
    text = path.read_text()

    # Ensure mandatory imports exist
    for imp in required_imports:
        if imp not in text:
            text = imp + "\n" + text

    text = remove_old_build_model(text)

    # Insert new build_model() at END of controller class
    class_pattern = r"class\s+(\w+)\s*\(\s*SofaPysimBlocksController\s*\)\s*:"
    match = re.search(class_pattern, text)

    if not match:
        raise RuntimeError("No class inheriting SofaPysimBlocksController found.")

    class_start = match.end()  # position after class header
    # find next class OR eof
    next_class = re.search(r"\nclass\s+", text[class_start:])
    class_end = class_start + (next_class.start() if next_class else len(text) - class_start)

    # Insert code with correct indentation
    insertion = "\n" + build_model_code + "\n"
    new_text = text[:class_end] + insertion + text[class_end:]

    return new_text




# ============================================================================
# 6. MAIN GENERATION FUNCTION
# ============================================================================

def generate_sofa_controller(blocks, connections, simulation, controller_path, dry_run=False):
    """
    Main function called by CLI.
    Generates:
      - parameters_auto.py (in same directory as controller)
      - auto build_model() injected into controller
    """

    # 1. Transform SofaPlant if needed
    blocks_sofa = [transform_block_for_sofa(blk) for blk in blocks]

    # 2. Write parameters_auto.py
    controller_path = Path(controller_path)
    controller_dir = controller_path.parent
    params_path = controller_dir / "parameters_auto.py"

    params_src = generate_parameters(blocks_sofa, simulation)
    params_text = "\n".join(params_src)
    if dry_run:
        print("\n----- DRY RUN PARAMETERS_AUTO.PY (no changes written) -----")
        print(params_text)
    else:
        params_path.write_text(params_text)
        print(f"[OK] parameters_auto.py written to {params_path}")

    # 3. Required imports to add
    required_imports = {"from parameters_auto import *", "from pySimBlocks import Model"}
    for blk in blocks_sofa:
        module, class_name = resolve_block_import(blk["from"], blk["type"])
        required_imports.add(f"from {module} import {class_name}")

    # 4. Create build_model() code
    logs = simulation.get("log", [])
    build_model_code = generate_build_model_code(blocks_sofa, connections, logs)

    # 5. Inject into controller
    new_text = inject_build_model(controller_path, build_model_code, required_imports)

    if dry_run:
        print("\n----- DRY RUN SOFA CONTROLLER (no changes written) -----")
        print(new_text)
    else:
        controller_path.write_text(new_text)
        print(f"[OK] Updated controller with auto-generated build_model(): {controller_path}")
